//
//---------------------------------------------------------------------------
//  THIS FILE WAS AUTOMATICALLY GENERATED BY THE STANFORD GENESIS2 ENGINE
//  FOR MORE INFORMATION, CONTACT OFER SHACHAM FROM THE STANFORD VLSI GROUP
//  THIS VERSION OF GENESIS2 IS NOT TO BE USED FOR ANY COMMERCIAL USE
//---------------------------------------------------------------------------
//
//  
//	-----------------------------------------------
//	|            Genesis Release Info             |
//	|  $Change: 11012 $ --- $Date: 2012/09/13 $   |
//	-----------------------------------------------
//	
//
//  Source file: /afs/ir.stanford.edu/users/a/s/asampat/EE271/assignment3-andrew/ee271-assignment3/rtl/bbox.vp
//  Source template: bbox
//
// --------------- Begin Pre-Generation Parameters Status Report ---------------
//
//	From 'generate' statement (priority=5):
// Parameter Radix 	= 10
// Parameter Vertices 	= 3
// Parameter Axis 	= 3
// Parameter SigFig 	= 24
// Parameter Colors 	= 3
// Parameter PipelineDepth 	= 3
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Command Line input (priority=4):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From XML input (priority=3):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Config File input (priority=2):
//
// ---------------- End Pre-Generation Pramameters Status Report ----------------

/*
 * Bounding Box Module
 *     
 * Inputs: 
 *   3 x,y,z vertices corresponding to tri 
 *   1 valid bit, indicating triangle is valid data
 * 
 *  Config Inputs:
 *   2 x,y vertices indicating screen dimensions
 *   1 integer representing square root of SS (16MSAA->4)
 *      we will assume config values are held in some
 *      register and are valid given a valid polygon
 * 
 *  Control Input:
 *   1 halt signal indicating that no work should be done 
 * 
 * Outputs:
 *   2 vertices describing a clamped bounding box
 *   1 Valid signal indicating that bounding 
 *           box and triangle value is valid
 *   3 x,y vertices corresponding to tri
 * 
 * Global Signals: 
 *   clk, rst
 * 
 * Function:
 *   Determine a bounding box for the polygon
 *   represented by the vertices.
 * 
 *   Clamp the Bounding Box to the subsample pixel
 *   space
 *   
 *   Clip the Bounding Box to Screen Space
 *
 *   Halt operating but retain values if next stage is busy
 *
 * 
 * Long Description:
 *   This bounding box block accepts a polygon described with three
 *   vertices and determines a set of sample points to test against
 *   the micropolygon.  These sample points correspond to the 
 *   either the pixels in the final image or the pixel fragments 
 *   that compose the pixel if multisample anti-aliasing (MSAA)
 *   is enabled.
 * 
 *   The inputs to the box are clocked with a bank of dflops.  
 * 
 *   After the data is clocked, a bounding box is determined 
 *   for the micropolygon. A bounding box can be determined 
 *   through calculating the maxima and minima for x and y to 
 *   generate a lower left vertice and upper right
 *   vertice.  This data is then clocked.
 * 
 *   The bounding box next needs to be clamped to the fragment grid.
 *   This can be accomplished through rounding the bounding box values
 *   to the fragment grid.  Additionally, any sample points that exist
 *   outside of screen space should be rejected.  So the bounding box
 *   can be clipped to the visible screen space.  This clipping is done
 *   using the screen signal.
 *
 *   The Halt signal is utilized to hold the current polygon bounding box.
 *   This is because one bounding box operation could correspond to
 *   multiple sample test operations later in the pipe.  As these samples
 *   can take a number of cycles to complete, the data held in the bounding
 *   box stage needs to be preserved.  The halt signal is also required for 
 *   when the write device is full/busy.
 * 
 *   The valid signal is utilized to indicate whether or a polygon 
 *   is actual data.  This can be useful if the device being read from,
 *   has no more micropolygons.
 * 
 * 
 * 
 *   Author: John Brunhaver
 *   Created:      Thu 07/23/09
 *   Last Updated: Fri 09/30/10
 *
 *   Copyright 2009 <jbrunhaver@gmail.com>   
 */

/* A Note on Signal Names:
 *
 * Most signals have a suffix of the form _RxxxxN 
 * where R indicates that it is a Raster Block signal
 * xxxx indicates the clock slice that it belongs to
 * N indicates the type of signal that it is.
 *    H indicates logic high, 
 *    L indicates logic low,
 *    U indicates unsigned fixed point, 
 *    S indicates signed fixed point.
 * 
 */

/* ***************************************************************************
 * Change bar:
 * -----------
 * Date           Author    Description
 * Sep 19, 2012   jingpu    ported from John's original code to Genesis
 *                          
 * ***************************************************************************/

/******************************************************************************
 * PARAMETERIZATION
 * ***************************************************************************/
// SigFig (_GENESIS2_INHERITANCE_PRIORITY_) = 24
//
// Radix (_GENESIS2_INHERITANCE_PRIORITY_) = 10
//
// Vertices (_GENESIS2_INHERITANCE_PRIORITY_) = 3
//
// Axis (_GENESIS2_INHERITANCE_PRIORITY_) = 3
//
// Colors (_GENESIS2_INHERITANCE_PRIORITY_) = 3
//
// PipelineDepth (_GENESIS2_INHERITANCE_PRIORITY_) = 3
//



module bbox_unq1
  (
   //Input Signals
   input logic signed [24-1:0] 	poly_R10S[3-1:0][3-1:0] , // Sets X,Y Fixed Point Values
   input logic 				unsigned [24-1:0] color_R10U[3-1:0] , // Color of Poly
   input logic 				isQuad_R10H , // Is Poly Quad?
   input logic 				validPoly_R10H , // Valid Data for Operation

   //Control Signals
   input logic 				halt_RnnnnL, // Indicates No Work Should Be Done
   input logic signed [24-1:0] 	screen_RnnnnS[1:0] , // Screen Dimensions
   input logic [3:0] 			subSample_RnnnnU , // SubSample_Interval

   //Global Signals
   input logic 				clk, // Clock 
   input logic 				rst, // Reset

   //Outout Signals
   output logic signed [24-1:0] poly_R13S[3-1:0][3-1:0], // 4 Sets X,Y Fixed Point Values
   output logic 			unsigned [24-1:0] color_R13U[3-1:0] , // Color of Poly
   output logic 			isQuad_R13H, // Is Poly Quad?
   output logic signed [24-1:0] box_R13S[1:0][1:0], // 2 Sets X,Y Fixed Point Values  
   output logic 			validPoly_R13H                  // Valid Data for Operation
   );
   
   
   //Signals In Clocking Order

   //R10 Signals
   logic [1:0][5:0] 			cmp_R10H ;             // Comparison Results
   logic [1:0][1:0][3-1:0] 	bbox_sel_R10H ;        // Decoded Select for Unclamped Bbox  
   logic signed [24-1:0] 	box_R10S[1:0][1:0];    // 2 Sets X,Y Fixed Point Values    
   logic signed [24-1:0] 	rounded_box_R10S[1:0][1:0];  // 2 Sets X,Y Fixed Point Values   
   logic signed [24-1:0] 	increment_box_R10S[1:0];     // 1 Set X,Y Fixed Point Values 
   logic [1:0][1:0] 			clamp_R10H;                  // signal require clamping
   logic [1:0][1:0] 			invalidate_R10H;             // polygon out of bounds
   logic signed [24-1:0] 	out_box_R10S[1:0][1:0];      // bounds for output
   logic 				outvalid_R10H;               // output is valid
   //R10 Signals
   
   // output for retiming registers
   logic signed [24-1:0] 	poly_R13S_retime[3-1:0][3-1:0]; // 4 Sets X,Y Fixed Point Values
   logic 				unsigned [24-1:0] color_R13U_retime[3-1:0];        // Color of Poly
   logic signed [24-1:0] 	box_R13S_retime[1:0][1:0];             // 2 Sets X,Y Fixed Point Values  
   logic 				isQuad_R13H_retime;                   // Is Poly Quad?
   logic 				validPoly_R13H_retime ;                 // Valid Data for Operation
   // output for retiming registers
	
	//logic for backface culling
  logic signed [24-5:0] edges [1:0][1:0]; // two edges, two axes. edges 1-2 and 2-3
	logic signed [47:0] z_crossproduct, z1, z2;	
	logic cull;
	//log for bubble smashing
	logic halt_smash;
   
	//Backface culling. Detect backward facing polygons, set valid_samp low
	 always_comb begin
	 	//v2 - v1
	 	edges[0][0] = poly_R10S[1][0][24-5:0] - poly_R10S[0][0][24-5:0]; //v2[x]-v1[x]
		edges[0][1] = poly_R10S[1][1][24-5:0] - poly_R10S[0][1][24-5:0]; //v2[y]-v1[y]

		//v3-v2
	 	edges[1][0] = poly_R10S[2][0][24-5:0] - poly_R10S[1][0][24-5:0]; //v3[x]-v2[x]
		edges[1][1] = poly_R10S[2][1][24-5:0] - poly_R10S[1][1][24-5:0]; //v3[y]-v2[y]

		z_crossproduct = (edges[0][0]*edges[1][1])-(edges[0][1]*edges[1][0]); //z output of cross product
		cull = (z_crossproduct > 0) ? 1'b1 : 1'b0; //z > 0 implies backfacing which means cull
	 end 

	 //Bubble smashing
	 /*Halt signal is logic LOW. So this combined signal should be LOW if we want it to halt.
		 As such, this signal will only halt the bbox if the halt signal is LOW 
		 AND the outvalid is HIGH. */
	 assign halt_smash = halt_RnnnnL | ~validPoly_R13H;

	
	   /*	//v2 - v1
	 	assign edges[0][0] = poly_R10S[1][0] - poly_R10S[0][0]; //v2[x]-v1[x]
		assign edges[0][1] = poly_R10S[1][1] - poly_R10S[0][1]; //v2[y]-v1[y]

		//v3-v2
	 	assign edges[1][0] = poly_R10S[2][0] - poly_R10S[1][0]; //v3[x]-v2[x]
		assign edges[1][1] = poly_R10S[2][1] - poly_R10S[1][1]; //v3[y]-v2[y]

		assign z1 = edges[0][0]*edges[1][1];
		assign z2 = edges[0][1]*edges[1][0];
		
		assign z_crossproduct = z1 - z2; //z output of cross product
		assign cull = (z_crossproduct > 0) ? 1'b1 : 1'b0; //z > 0 implies backfacing which means cull
*/

   //Note: <= might be faster than < and functionally equivelant here
   always_comb begin
      //Compare X
      cmp_R10H[0][0] =  poly_R10S[0][0] <  poly_R10S[1][0] ;
      cmp_R10H[0][1] =  poly_R10S[0][0] <  poly_R10S[2][0] ;
      cmp_R10H[0][2] =  poly_R10S[1][0] <  poly_R10S[2][0] ;
      cmp_R10H[0][5:3] = 3'b0;
      
      //Compare Y
      cmp_R10H[1][0] =  poly_R10S[0][1] <  poly_R10S[1][1] ;
      cmp_R10H[1][1] =  poly_R10S[0][1] <  poly_R10S[2][1] ;
      cmp_R10H[1][2] =  poly_R10S[1][1] <  poly_R10S[2][1] ;
      cmp_R10H[1][5:3] = 3'b0;
   end 
   
   always_comb begin
      //Decoded Select
      //  sel[n][m][p]
      //  n=0 -> ll n=1 -> ur
      //  m=0 -> x  m=1 -> y
      //  p correspeonds to vertice index
      
      // X
      bbox_sel_R10H[0][0][0] =  cmp_R10H[0][0] &  cmp_R10H[0][1] ;	    
      bbox_sel_R10H[0][0][1] = !cmp_R10H[0][0] &  cmp_R10H[0][2] ; 
      bbox_sel_R10H[0][0][2] = !cmp_R10H[0][1] & !cmp_R10H[0][2] ; 
      bbox_sel_R10H[1][0][0] = !cmp_R10H[0][0] & !cmp_R10H[0][1] ; 
      bbox_sel_R10H[1][0][1] =  cmp_R10H[0][0] & !cmp_R10H[0][2] ; 
      bbox_sel_R10H[1][0][2] =  cmp_R10H[0][1] &  cmp_R10H[0][2] ; 
      
      // Y
      bbox_sel_R10H[0][1][0] =  cmp_R10H[1][0] &  cmp_R10H[1][1]  ; 
      bbox_sel_R10H[0][1][1] = !cmp_R10H[1][0] &  cmp_R10H[1][2]  ; 
      bbox_sel_R10H[0][1][2] = !cmp_R10H[1][1] & !cmp_R10H[1][2]  ; 
      bbox_sel_R10H[1][1][0] = !cmp_R10H[1][0] & !cmp_R10H[1][1]  ; 
      bbox_sel_R10H[1][1][1] =  cmp_R10H[1][0] & !cmp_R10H[1][2]  ; 
      bbox_sel_R10H[1][1][2] =  cmp_R10H[1][1] &  cmp_R10H[1][2]  ; 

      //Check that the Select is OneHot (only one bit in array is 1)
      assert( rst | $onehot( bbox_sel_R10H[0][0] )) 
	else $error("%b \n",bbox_sel_R10H[0][0]) ;
      assert( rst |  $onehot( bbox_sel_R10H[1][0] )) 
	else $error("%b \n",bbox_sel_R10H[1][0]);
      assert( rst |  $onehot( bbox_sel_R10H[0][1] )) 
	else $error("%b \n",bbox_sel_R10H[0][1]) ;
      assert( rst |  $onehot( bbox_sel_R10H[1][1] )) 
	else $error("%b \n",bbox_sel_R10H[1][1]);
      //Check that the Select is OneHot (only one bit in array is 1)
      
      //Perform the Selection
      //  note that unique indicates that 
      //  one and only one select signal will be valid
      //  and that only one case event will occur   
      //
      //  This will synthesize to a simple mux with decoded select
      
      //Upper Right X Select
      unique case( 1'b1 )
	( bbox_sel_R10H[1][0][0] ): box_R10S[1][0] = poly_R10S[0][0] ;
	( bbox_sel_R10H[1][0][1] ): box_R10S[1][0] = poly_R10S[1][0] ;
	( bbox_sel_R10H[1][0][2] ): box_R10S[1][0] = poly_R10S[2][0] ;
      endcase // 
      
      //Lower Left X Select
      unique case( 1'b1 )
	( bbox_sel_R10H[0][0][0] ): box_R10S[0][0] = poly_R10S[0][0] ;
	( bbox_sel_R10H[0][0][1] ): box_R10S[0][0] = poly_R10S[1][0] ;
	( bbox_sel_R10H[0][0][2] ): box_R10S[0][0] = poly_R10S[2][0] ;
      endcase //

      //Upper Right Y Select
      unique case( 1'b1 )
	( bbox_sel_R10H[1][1][0] ): box_R10S[1][1] = poly_R10S[0][1] ;
	( bbox_sel_R10H[1][1][1] ): box_R10S[1][1] = poly_R10S[1][1] ;
	( bbox_sel_R10H[1][1][2] ): box_R10S[1][1] = poly_R10S[2][1] ;
      endcase // 
      
      //Lower Left Y Select
      unique case( 1'b1 )
	( bbox_sel_R10H[0][1][0] ): box_R10S[0][1] = poly_R10S[0][1] ;
	( bbox_sel_R10H[0][1][1] ): box_R10S[0][1] = poly_R10S[1][1] ;
	( bbox_sel_R10H[0][1][2] ): box_R10S[0][1] = poly_R10S[2][1] ;
      endcase //

      //End Selection of Bounding Box    
      
   end // always_comb 

   
   //Round Values to Subsample Interval
   //
   // We will use the floor operation for rounding.
   // To floor a signal, we simply turn all of the bits
   // below a specific 10 to 0.
   // The complication here is that there are 4 setting.
   // 1x MSAA eq. to 1 sample per pixel
   // 4x MSAA eq to 4 samples per pixel, a sample is
   // half a pixel on a side
   // 16x MSAA eq to 16 sample per pixel, a sample is
   // a quarter pixel on a side.  
   // 64x MSAA eq to 64 samples per pixel, a sample is
   // an eighth of a pixel on a side.

   // Note: Cleverly converting the MSAA signal
   //       to a mask would allow you to do this operation
   //       as a bitwise and operation.

   // Why is it a floor operation?
   //  TODO -> Explanation of why it is floor
   
   //Round LowerLeft and UpperRight for X and Y
   always_comb begin
      
      //Integer Portion of LL Remains the Same 
      rounded_box_R10S[0][0][24-1:10] 
     = box_R10S[0][0][24-1:10];

      //Fractional Portion LL less than Subsample set to 0
      rounded_box_R10S[0][0][10-4:0] 
	= 7'b0;
      
      //Mux for Correct Roundoff Point 
      assert( $onehot( subSample_RnnnnU )) else $fatal( "onehot\n");
      
      unique case( subSample_RnnnnU )
	(4'b0001): // 64x MSAA
	  rounded_box_R10S[0][0][10-1:10-3] 
	       = { box_R10S[0][0][10-1:10-3] };  
	(4'b0010): // 16x MSAA
		 rounded_box_R10S[0][0][10-1:10-3] 
	  = { box_R10S[0][0][10-1:10-2] , 1'b0 };  
	(4'b0100): // 4x MSAA
	    rounded_box_R10S[0][0][10-1:10-3] 
	  = { box_R10S[0][0][10-1] , 2'b0 }; 
	(4'b1000): // 1x MSAA
	    rounded_box_R10S[0][0][10-1:10-3] 
	  = { 3'b0 } ;
      endcase // case ( subSample_RnnnnU )
      
      //Assertion Checks at end of Module
      
   end // always_comb
   always_comb begin
      
      //Integer Portion of LL Remains the Same 
      rounded_box_R10S[0][1][24-1:10] 
     = box_R10S[0][1][24-1:10];

      //Fractional Portion LL less than Subsample set to 0
      rounded_box_R10S[0][1][10-4:0] 
	= 7'b0;
      
      //Mux for Correct Roundoff Point 
      assert( $onehot( subSample_RnnnnU )) else $fatal( "onehot\n");
      
      unique case( subSample_RnnnnU )
	(4'b0001): // 64x MSAA
	  rounded_box_R10S[0][1][10-1:10-3] 
	       = { box_R10S[0][1][10-1:10-3] };  
	(4'b0010): // 16x MSAA
		 rounded_box_R10S[0][1][10-1:10-3] 
	  = { box_R10S[0][1][10-1:10-2] , 1'b0 };  
	(4'b0100): // 4x MSAA
	    rounded_box_R10S[0][1][10-1:10-3] 
	  = { box_R10S[0][1][10-1] , 2'b0 }; 
	(4'b1000): // 1x MSAA
	    rounded_box_R10S[0][1][10-1:10-3] 
	  = { 3'b0 } ;
      endcase // case ( subSample_RnnnnU )
      
      //Assertion Checks at end of Module
      
   end // always_comb
   always_comb begin
      
      //Integer Portion of LL Remains the Same 
      rounded_box_R10S[1][0][24-1:10] 
     = box_R10S[1][0][24-1:10];

      //Fractional Portion LL less than Subsample set to 0
      rounded_box_R10S[1][0][10-4:0] 
	= 7'b0;
      
      //Mux for Correct Roundoff Point 
      assert( $onehot( subSample_RnnnnU )) else $fatal( "onehot\n");
      
      unique case( subSample_RnnnnU )
	(4'b0001): // 64x MSAA
	  rounded_box_R10S[1][0][10-1:10-3] 
	       = { box_R10S[1][0][10-1:10-3] };  
	(4'b0010): // 16x MSAA
		 rounded_box_R10S[1][0][10-1:10-3] 
	  = { box_R10S[1][0][10-1:10-2] , 1'b0 };  
	(4'b0100): // 4x MSAA
	    rounded_box_R10S[1][0][10-1:10-3] 
	  = { box_R10S[1][0][10-1] , 2'b0 }; 
	(4'b1000): // 1x MSAA
	    rounded_box_R10S[1][0][10-1:10-3] 
	  = { 3'b0 } ;
      endcase // case ( subSample_RnnnnU )
      
      //Assertion Checks at end of Module
      
   end // always_comb
   always_comb begin
      
      //Integer Portion of LL Remains the Same 
      rounded_box_R10S[1][1][24-1:10] 
     = box_R10S[1][1][24-1:10];

      //Fractional Portion LL less than Subsample set to 0
      rounded_box_R10S[1][1][10-4:0] 
	= 7'b0;
      
      //Mux for Correct Roundoff Point 
      assert( $onehot( subSample_RnnnnU )) else $fatal( "onehot\n");
      
      unique case( subSample_RnnnnU )
	(4'b0001): // 64x MSAA
	  rounded_box_R10S[1][1][10-1:10-3] 
	       = { box_R10S[1][1][10-1:10-3] };  
	(4'b0010): // 16x MSAA
		 rounded_box_R10S[1][1][10-1:10-3] 
	  = { box_R10S[1][1][10-1:10-2] , 1'b0 };  
	(4'b0100): // 4x MSAA
	    rounded_box_R10S[1][1][10-1:10-3] 
	  = { box_R10S[1][1][10-1] , 2'b0 }; 
	(4'b1000): // 1x MSAA
	    rounded_box_R10S[1][1][10-1:10-3] 
	  = { 3'b0 } ;
      endcase // case ( subSample_RnnnnU )
      
      //Assertion Checks at end of Module
      
   end // always_comb
   //Round Values to Subsample Interval


   
   //Check if Unclamped Box Requires Clipping or Rejection
   always_comb begin
      //Clamp if LL is down/left of screen origin
      clamp_R10H[0][0] = box_R10S[0][0] < 0 ;
      clamp_R10H[0][1] = box_R10S[0][1] < 0 ;

      //Clamp if UR is up/right of Screen
      clamp_R10H[1][0] = box_R10S[1][0] > screen_RnnnnS[0] ;
      clamp_R10H[1][1] = box_R10S[1][1] > screen_RnnnnS[1] ;

      //Invalid if BBox is up/right of Screen
      invalidate_R10H[0][0] = box_R10S[0][0] > screen_RnnnnS[0] ;
      invalidate_R10H[0][1] = box_R10S[0][1] > screen_RnnnnS[1] ;

      //Invalid if BBox is down/left of Screen
      invalidate_R10H[1][0] = box_R10S[1][0] < 0 ;	    
      invalidate_R10H[1][1] = box_R10S[1][1] < 0 ;	    
   end
   //Check if Unclamped Box Requires Clipping or Rejection

   
   //Select Between Clipped Bounds and Rounded Bounds
   always_comb begin
      out_box_R10S[0][0] = 
			   clamp_R10H[0][0] ? 0 : rounded_box_R10S[0][0] ;
      out_box_R10S[0][1] = 
			   clamp_R10H[0][1] ? 0 : rounded_box_R10S[0][1] ;
      out_box_R10S[1][0] = 
			   clamp_R10H[1][0] ? screen_RnnnnS[0] : rounded_box_R10S[1][0] ;
      out_box_R10S[1][1] = 
			   clamp_R10H[1][1] ? screen_RnnnnS[1] : rounded_box_R10S[1][1];
   end
   //Select Between Screen Bounds and Rounded Bounds
   
   assign  outvalid_R10H = ~( | invalidate_R10H ) & validPoly_R10H & ~cull;
   
   //Flop Clamped Box to R13_retime with retiming registers
   dff3_unq1  d_bbx_r1 (
			       .in(poly_R10S) , 
			       .clk(clk) , .reset(rst), .en(halt_smash),
			       .out(poly_R13S_retime));
   
   dff2_unq1  d_bbx_r2(
			      .in(color_R10U) , 
			      .clk(clk) , .reset(rst), .en(halt_smash),
			      .out(color_R13U_retime));
   
   dff3_unq2  d_bbx_r3 (
			       .in(out_box_R10S) , 
			       .clk(clk) , .reset(rst), .en(halt_smash),
			       .out(box_R13S_retime));
   
   dff_unq2  d_bbx_r4(
			      .in({isQuad_R10H, outvalid_R10H}) , 
			      .clk(clk) , .reset(rst), .en(halt_smash),
			      .out({isQuad_R13H_retime, validPoly_R13H_retime}));
   //Flop Clamped Box to R13_retime with retiming registers
   
   
   
   //Flop R13_retime to R13 with fixed registers
   dff3_unq3  d_bbx_f1 (
			       .in(poly_R13S_retime) , 
			       .clk(clk) , .reset(rst), .en(halt_smash),
			       .out(poly_R13S));
   
   dff2_unq3  d_bbx_f2(
			      .in(color_R13U_retime) , 
			      .clk(clk) , .reset(rst), .en(halt_smash),
			      .out(color_R13U));
   
   dff3_unq4  d_bbx_f3 (
			       .in(box_R13S_retime) , 
			       .clk(clk) , .reset(rst), .en(halt_smash),
			       .out(box_R13S));
   
   dff_unq4  d_bbx_f4(
			      .in({isQuad_R13H_retime, validPoly_R13H_retime}) , 
			      .clk(clk) , .reset(rst), .en(halt_smash),
			      .out({isQuad_R13H, validPoly_R13H}));
   //Flop R13_retime to R13 with fixed registers


   //Error Checking Assertions

   //Define a Less Than Property
   //  
   //  a should be less than b
   property rb_lt( rst, a , b , c );
      @(posedge clk) rst | ((a<=b) | !c);
   endproperty

   //Check that Lower Left of Bounding Box is less than equal Upper Right
   assert property( rb_lt( rst, box_R13S[0][0] , box_R13S[1][0] , validPoly_R13H ));
   assert property( rb_lt( rst, box_R13S[0][1] , box_R13S[1][1] , validPoly_R13H ));
   //Check that Lower Left of Bounding Box is less than equal Upper Right
   
   //Error Checking Assertions

   
endmodule 








